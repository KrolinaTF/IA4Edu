Estrategia de Refactorización Completa - Sistema ABP

  🎯 Visión Arquitectónica Target

  Principios Rectores

  1. Domain-Driven Design (DDD): Separar lógica de dominio de infraestructura
  2. Clean Architecture: Dependencias apuntan hacia el dominio
  3. SOLID Principles: Cada clase una responsabilidad, extensible sin modificación
  4. Dependency Injection: Desacoplar componentes para testabilidad
  5. Event-Driven: Comunicación asíncrona entre bounded contexts
          builder.with_estructura_fases(contexto['estructura_fases'])
  📋 Fase 0: Preparación y Auditoría (Semana 1)
      return builder.with_adaptaciones_dua().build()
  Day 1-2: Data Consolidation Emergency
  Beneficios del Builder Pattern:
  # Script de emergencia para consolidar datosesteable independientemente
  ./scripts/consolidate_data.pys de prompt sin modificar código existente
  ├── Merge perfiles_4_primaria.json conflictsarada de lógica de negocio
  ├── Resolve k_celula.txt version discrepancies self-documenting
  ├── Establish single source of truth for embeddings
  └── Clean temp directories and establish retention policy
  🔬 Conclusión Científica General
  Day 3-5: Dependency Mapping & Test Baseline
  Evaluación por Principios SOLID:
  # Crear mapa de dependencias actual
  dependency_graph = analyze_current_dependencies()Veredicto           |
  test_coverage = run_baseline_tests()  # Establecer baseline antes de cambios
  | Fusión Títulos | ✅   | ✅   | ✅   | ✅   | ✅   | APROBAR             |
  # Identificar breaking points seguros para refactoringZAR            |
  safe_refactor_points = identify_isolated_components()BAR CON BUILDER |

  🏗️ Fase 1: Establecer Foundations (Semanas 2-4)

  Semana 2: Domain Model & Core Entities
    - Lines of Code: -15
  # src/domain/entities/ity: -3
  class Student:ility: +25%
      def __init__(self, student_id: StudentId, profile: StudentProfile):
          self._student_id = student_id
          self._profile = profile00% extensibilidad)
          self._adaptations = []por clase
    - Maintainability: +150%
      def add_adaptation(self, adaptation: Adaptation) -> None:
          # Business rules for adaptations
    - Lines of Code: +40 (pero -60% complexity)
      def can_handle_task(self, task: Task) -> bool:
          # Domain logic for task-student matching

  class Activity:inal:
      def __init__(self, activity_id: ActivityId, metadata: ActivityMetadata):
          self._activity_id = activity_idtítulo (trivial, alta ganancia)
          self._metadata = metadataorganización de etapas (usar Strategy)
          self._phases = [] de prompts SOLO con Builder pattern

      def add_phase(self, phase: ActivityPhase) -> None:roblema más profundo - falta de patterns arquitectónicos apropriados. En
          # Validation and business rulesecesita refactoring estructural usando patterns establecidos (Strategy, Builder) que
  resuelvan tanto la duplicación como los problemas de mantenibilidad a largo plazo.
      def estimate_duration(self) -> Duration:
          # Domain calculation logic─────────────────────────────────────────────────────────────────────────────────────────────────╮
│ >                                                                                                                                  │
  class Task:────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
      def __init__(self, task_id: TaskId, description: str, complexity: Complexity):            Context left until auto-compact: 28%
          self._task_id = task_id                     ✗ Auto-update failed · Try claude doctor or npm i -g @anthropic-ai/claude-code
          self._description = description
          self._complexity = complexity
          self._requirements = []

  Semana 3: Repository Interfaces & Infrastructure

  # src/domain/repositories/
  class StudentRepository(ABC):
      @abstractmethod
      def find_by_grade(self, grade: Grade) -> List[Student]:
          pass

      @abstractmethod
      def save(self, student: Student) -> None:
          pass

  class ActivityRepository(ABC):
      @abstractmethod
      def find_similar(self, query: ActivityQuery) -> List[Activity]:
          pass

      @abstractmethod
      def find_by_id(self, activity_id: ActivityId) -> Optional[Activity]:
          pass

  # src/infrastructure/repositories/
  class JsonStudentRepository(StudentRepository):
      def __init__(self, file_path: str, validator: DataValidator):
          self._file_path = file_path
          self._validator = validator

      def find_by_grade(self, grade: Grade) -> List[Student]:
          # Implementation with proper error handling

  class EmbeddingActivityRepository(ActivityRepository):
      def __init__(self, embedding_service: EmbeddingService, cache: CacheService):
          self._embedding_service = embedding_service
          self._cache = cache

  Semana 4: Application Services Layer

  # src/application/services/
  class ActivityGenerationService:
      def __init__(self,
                   activity_repo: ActivityRepository,
                   llm_service: LLMService,
                   validation_service: ValidationService):
          self._activity_repo = activity_repo
          self._llm_service = llm_service
          self._validation_service = validation_service

      def generate_ideas(self, request: GenerateIdeasRequest) -> GenerateIdeasResponse:
          # Clean application logic without infrastructure concerns
          similar_activities = self._activity_repo.find_similar(request.to_query())
          prompt = self._build_prompt(request, similar_activities)
          ideas = self._llm_service.generate_ideas(prompt)
          validated_ideas = self._validation_service.validate_ideas(ideas)
          return GenerateIdeasResponse(validated_ideas)

  class StudentProfilingService:
      def __init__(self,
                   student_repo: StudentRepository,
                   profiling_strategy: ProfilingStrategy):
          self._student_repo = student_repo
          self._profiling_strategy = profiling_strategy

      def analyze_students(self, grade: Grade) -> List[StudentAnalysis]:
          students = self._student_repo.find_by_grade(grade)
          return [self._profiling_strategy.analyze(student) for student in students]

  class TaskAssignmentService:
      def __init__(self,
                   assignment_strategy: AssignmentStrategy,
                   compatibility_service: CompatibilityService):
          self._assignment_strategy = assignment_strategy
          self._compatibility_service = compatibility_service

      def optimize_assignments(self,
                             tasks: List[Task],
                             students: List[Student]) -> AssignmentResult:
          compatibility_matrix = self._compatibility_service.calculate_matrix(tasks, students)
          return self._assignment_strategy.optimize(compatibility_matrix)

  🔄 Fase 2: Strategy Patterns & Business Logic (Semanas 5-7)

  Semana 5: Estrategias de Generación

  # src/domain/strategies/generation/
  class ActivityGenerationStrategy(ABC):
      @abstractmethod
      def generate(self, context: GenerationContext) -> List[ActivityIdea]:
          pass

  class SimilarityBasedGenerationStrategy(ActivityGenerationStrategy):
      def generate(self, context: GenerationContext) -> List[ActivityIdea]:
          # Usar actividades similares como base

  class PromptBasedGenerationStrategy(ActivityGenerationStrategy):
      def generate(self, context: GenerationContext) -> List[ActivityIdea]:
          # Generación desde cero con LLM

  class HybridGenerationStrategy(ActivityGenerationStrategy):
      def __init__(self,
                   similarity_strategy: SimilarityBasedGenerationStrategy,
                   prompt_strategy: PromptBasedGenerationStrategy):
          self._similarity_strategy = similarity_strategy
          self._prompt_strategy = prompt_strategy

      def generate(self, context: GenerationContext) -> List[ActivityIdea]:
          # Combinar ambas estrategias inteligentemente

  Semana 6: Estrategias de Asignación

  # src/domain/strategies/assignment/
  class AssignmentStrategy(ABC):
      @abstractmethod
      def optimize(self, compatibility_matrix: CompatibilityMatrix) -> AssignmentResult:
          pass

  class NeurotypeAwareAssignmentStrategy(AssignmentStrategy):
      def optimize(self, compatibility_matrix: CompatibilityMatrix) -> AssignmentResult:
          # Optimización considerando neurotipos específicos

  class BalancedWorkloadAssignmentStrategy(AssignmentStrategy):
      def optimize(self, compatibility_matrix: CompatibilityMatrix) -> AssignmentResult:
          # Distribución equilibrada de carga de trabajo

  class CompositeAssignmentStrategy(AssignmentStrategy):
      def __init__(self, strategies: List[AssignmentStrategy], weights: List[float]):
          self._strategies = strategies
          self._weights = weights

      def optimize(self, compatibility_matrix: CompatibilityMatrix) -> AssignmentResult:
          # Combinar múltiples estrategias con pesos

  Semana 7: Builders & Prompt Engineering

  # src/domain/builders/
  class PromptBuilder:
      def __init__(self):
          self._sections = {}
          self._context = {}

      def with_educational_context(self, context: EducationalContext) -> 'PromptBuilder':
          self._sections['educational'] = context
          return self

      def with_activity_reference(self, activity: Activity) -> 'PromptBuilder':
          self._sections['reference'] = activity
          return self

      def with_student_profiles(self, profiles: List[StudentProfile]) -> 'PromptBuilder':
          self._sections['profiles'] = profiles
          return self

      def with_adaptations(self, adaptations: List[Adaptation]) -> 'PromptBuilder':
          self._sections['adaptations'] = adaptations
          return self

      def build(self) -> Prompt:
          validator = PromptValidator()
          prompt = Prompt(self._sections)
          validator.validate(prompt)
          return prompt

  class ActivityBuilder:
      def __init__(self):
          self._phases = []
          self._metadata = {}
          self._tasks = []

      def with_phase(self, phase: ActivityPhase) -> 'ActivityBuilder':
          self._phases.append(phase)
          return self

      def with_task(self, task: Task) -> 'ActivityBuilder':
          self._tasks.append(task)
          return self

      def build(self) -> Activity:
          validator = ActivityValidator()
          activity = Activity(self._phases, self._tasks, self._metadata)
          validator.validate(activity)
          return activity

  ⚡ Fase 3: Event-Driven Communication (Semanas 8-10)

  Semana 8: Event System

  # src/domain/events/
  class DomainEvent(ABC):
      def __init__(self):
          self._occurred_on = datetime.now()
          self._event_id = EventId.generate()

  class ActivityIdeasGenerated(DomainEvent):
      def __init__(self, ideas: List[ActivityIdea], context: GenerationContext):
          super().__init__()
          self._ideas = ideas
          self._context = context

  class StudentsProfiled(DomainEvent):
      def __init__(self, profiles: List[StudentProfile]):
          super().__init__()
          self._profiles = profiles

  class TasksAssigned(DomainEvent):
      def __init__(self, assignments: AssignmentResult):
          super().__init__()
          self._assignments = assignments

  # src/application/event_handlers/
  class EventBus:
      def __init__(self):
          self._handlers = defaultdict(list)

      def subscribe(self, event_type: Type[DomainEvent], handler: EventHandler):
          self._handlers[event_type].append(handler)

      def publish(self, event: DomainEvent):
          for handler in self._handlers[type(event)]:
              handler.handle(event)

  class CacheInvalidationHandler(EventHandler):
      def handle(self, event: ActivityIdeasGenerated):
          # Invalidar cache cuando se generan nuevas ideas

  class MetricsCollectionHandler(EventHandler):
      def handle(self, event: TasksAssigned):
          # Recopilar métricas de asignación

  Semana 9: Workflow Orchestration

  # src/application/workflows/
  class ABPProjectWorkflow:
      def __init__(self,
                   activity_service: ActivityGenerationService,
                   profiling_service: StudentProfilingService,
                   assignment_service: TaskAssignmentService,
                   event_bus: EventBus):
          self._activity_service = activity_service
          self._profiling_service = profiling_service
          self._assignment_service = assignment_service
          self._event_bus = event_bus

      def execute(self, request: ABPProjectRequest) -> ABPProjectResult:
          # Orchestrate the complete workflow
          ideas = self._activity_service.generate_ideas(request.generation_request)
          self._event_bus.publish(ActivityIdeasGenerated(ideas, request.context))

          profiles = self._profiling_service.analyze_students(request.grade)
          self._event_bus.publish(StudentsProfiled(profiles))

          selected_activity = self._select_activity(ideas, request.selection_criteria)
          tasks = self._extract_tasks(selected_activity)

          assignments = self._assignment_service.optimize_assignments(tasks, profiles)
          self._event_bus.publish(TasksAssigned(assignments))

          return ABPProjectResult(selected_activity, tasks, assignments)

  class WorkflowState:
      def __init__(self):
          self._current_step = WorkflowStep.IDEA_GENERATION
          self._context = {}
          self._results = {}

      def transition_to(self, step: WorkflowStep):
          # State machine for workflow progression

  Semana 10: Caching & Performance

  # src/infrastructure/caching/
  class CacheService(ABC):
      @abstractmethod
      def get(self, key: str) -> Optional[Any]:
          pass

      @abstractmethod
      def set(self, key: str, value: Any, ttl: Optional[int] = None):
          pass

  class RedisCacheService(CacheService):
      def __init__(self, redis_client: Redis):
          self._redis = redis_client

  class InMemoryCacheService(CacheService):
      def __init__(self, max_size: int = 1000):
          self._cache = LRUCache(max_size)

  # src/infrastructure/performance/
  class EmbeddingCache:
      def __init__(self, cache_service: CacheService, embedding_service: EmbeddingService):
          self._cache = cache_service
          self._embedding_service = embedding_service

      def get_embedding(self, text: str) -> np.ndarray:
          cache_key = f"embedding:{hash(text)}"
          cached = self._cache.get(cache_key)
          if cached:
              return cached

          embedding = self._embedding_service.generate_embedding(text)
          self._cache.set(cache_key, embedding, ttl=3600)
          return embedding

  🔧 Fase 4: Infrastructure & Integration (Semanas 11-12)

  Semana 11: External Service Integration

  # src/infrastructure/external/
  class LLMService(ABC):
      @abstractmethod
      def generate_ideas(self, prompt: Prompt) -> List[ActivityIdea]:
          pass

      @abstractmethod
      def generate_embedding(self, text: str) -> np.ndarray:
          pass

  class OllamaLLMService(LLMService):
      def __init__(self, config: OllamaConfig, circuit_breaker: CircuitBreaker):
          self._config = config
          self._circuit_breaker = circuit_breaker
          self._client = OllamaClient(config)

      def generate_ideas(self, prompt: Prompt) -> List[ActivityIdea]:
          @self._circuit_breaker
          def _call_ollama():
              response = self._client.generate(prompt.to_string())
              return IdeaParser.parse(response)

          return _call_ollama()

  class CircuitBreaker:
      def __init__(self, failure_threshold: int = 5, timeout: int = 60):
          self._failure_threshold = failure_threshold
          self._timeout = timeout
          self._failure_count = 0
          self._last_failure_time = None
          self._state = CircuitState.CLOSED

  Semana 12: Configuration & Deployment

  # src/infrastructure/config/
  class Configuration:
      def __init__(self):
          self._config = self._load_config()

      def _load_config(self) -> Dict:
          # Load from environment variables, config files, etc.
          return {
              'ollama': {
                  'host': os.getenv('OLLAMA_HOST', 'localhost'),
                  'port': int(os.getenv('OLLAMA_PORT', '11434')),
                  'model': os.getenv('OLLAMA_MODEL', 'mistral')
              },
              'database': {
                  'connection_string': os.getenv('DB_CONNECTION')
              },
              'cache': {
                  'redis_url': os.getenv('REDIS_URL'),
                  'ttl': int(os.getenv('CACHE_TTL', '3600'))
              }
          }

  # src/infrastructure/di/
  class DIContainer:
      def __init__(self, config: Configuration):
          self._config = config
          self._services = {}
          self._setup_services()

      def _setup_services(self):
          # Repository layer
          self.register(StudentRepository, JsonStudentRepository, singleton=True)
          self.register(ActivityRepository, EmbeddingActivityRepository, singleton=True)

          # External services
          self.register(LLMService, OllamaLLMService, singleton=True)
          self.register(CacheService, RedisCacheService, singleton=True)

          # Application services
          self.register(ActivityGenerationService, ActivityGenerationService)
          self.register(StudentProfilingService, StudentProfilingService)
          self.register(TaskAssignmentService, TaskAssignmentService)

          # Workflows
          self.register(ABPProjectWorkflow, ABPProjectWorkflow)

  🧪 Fase 5: Testing & Quality Assurance (Semanas 13-14)

  Testing Strategy

  # tests/unit/domain/
  class TestStudent:
      def test_can_handle_task_with_matching_skills(self):
          # Test domain logic in isolation

      def test_add_adaptation_validates_business_rules(self):
          # Test business rule enforcement

  # tests/integration/application/
  class TestActivityGenerationService:
      def test_generate_ideas_with_similar_activities(self):
          # Test service integration with mocked repositories

  # tests/e2e/
  class TestABPWorkflow:
      def test_complete_workflow_from_request_to_result(self):
          # Test entire workflow with real implementations

  📊 Métricas de Éxito

  Antes vs Después

  | Métrica                       | Estado Actual                | Target Post-Refactor         | Método de Medición   |
  |-------------------------------|------------------------------|------------------------------|----------------------|
  | Cyclomatic Complexity         | 25+ (max)                    | <10 (max)                    | SonarQube analysis   |
  | Test Coverage                 | ~5%                          | 85%+                         | pytest-cov           |
  | Coupling                      | High (tightly coupled)       | Low (DI pattern)             | Dependency analysis  |
  | Cohesion                      | Low (mixed responsibilities) | High (single responsibility) | LCOM metrics         |
  | Performance (idea generation) | 30-60s                       | <10s                         | Load testing         |
  | Bug Fix Time                  | 1-2 days                     | 2-4 hours                    | Development tracking |
  | Feature Addition Time         | 2-3 weeks                    | 2-3 days                     | Development tracking |

  ROI Estimation

  Refactoring Investment: ~14 semanas de desarrollo
  Benefits:
  - Development velocity: +400% (semanas → días para features)
  - Bug reduction: +300% (mejor testabilidad)
  - Onboarding time: +500% (arquitectura clara)
  - Maintenance cost: -60% (menos deuda técnica)

  Break-even: ~6 meses
  Long-term ROI: +250% en 2 años

  🚀 Plan de Migración

  Zero-Downtime Strategy

  1. Strangler Fig Pattern: Nuevo código se implementa gradualmente
  2. Feature Flags: Switching entre implementación vieja y nueva
  3. Database Migration: Scripts automáticos para migrar datos
  4. Rollback Plan: Capacidad de volver al estado anterior en cualquier momento

  Risk Mitigation

  # Feature flag example
  if feature_flag('use_new_activity_generation'):
      result = new_activity_service.generate_ideas(request)
  else:
      result = legacy_coordinator.generar_ideas_actividades_hibrido(request)

  Esta estrategia transforma el codebase actual en una arquitectura limpia, mantenible y extensible, siguiendo principios de
  ingeniería de software establecidos y patterns de industria probados.