#!/usr/bin/env python3
"""
Sistema de Agentes H√≠brido Optimizado
Combina lo mejor de todos los sistemas anteriores:
- Feedback sem√°ntico autom√°tico (q_sistema_agentes_2)
- Validaci√≥n cu√°ntica con retry (sistema_agentes_fewshot)  
- Modularidad y tools (sistema_agentes_optimizado)
- Validaci√≥n incorporada ligera (sistema_agentes_hibrido)
- Agentes d√≥ciles + contexto rico separado
"""

import json
import os
import re
import logging
from datetime import datetime
from typing import Dict, List, Optional, Union, Tuple
from dataclasses import dataclass
from enum import Enum
from difflib import SequenceMatcher

# Configuraci√≥n de entorno (EXACTAMENTE igual que q_sistema_agentes_2.py)
os.environ["OLLAMA_BASE_URL"] = "http://192.168.1.10:11434"
os.environ["OLLAMA_HOST"] = "http://192.168.1.10:11434"
os.environ["OLLAMA_API_BASE"] = "http://192.168.1.10:11434"
os.environ["LITELLM_LOG"] = "DEBUG"

os.environ["OPENAI_API_KEY"] = "not-needed"
os.environ["OPENAI_MODEL_NAME"] = "qwen3:latest"
os.environ["CREWAI_DISABLE_TELEMETRY"] = "true"

os.environ["HTTPX_TIMEOUT"] = "120"

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger("HIBRIDO_OPTIMIZADO")

# Importaciones
try:
    from crewai import Agent, Task, Crew, Process
    from crewai.tools import BaseTool
    from langchain_community.llms import Ollama
    from quantum_enhancer import QuantumEnhancer, QISKIT_CONFIG
    logger.info("‚úÖ Dependencias importadas correctamente")
except ImportError as e:
    logger.error(f"‚ùå Error de importaci√≥n: {e}")
    raise ImportError("Instala dependencias: pip install crewai crewai-tools langchain-community")

# =============================================================================
# DATA CLASSES Y ENUMS
# =============================================================================

class AgenteSemantico(Enum):
    INSPIRADOR = "inspirador"
    PEDAGOGO = "pedagogo" 
    ARQUITECTO = "arquitecto"
    DIFERENCIADOR = "diferenciador"
    GENERAL = "general"

class NivelComplejidad(Enum):
    BASICA = "basica"
    INTERMEDIA = "intermedia"
    AVANZADA = "avanzada"
    EXPERTA = "experta"

@dataclass
class FeedbackInteligente:
    """Feedback procesado autom√°ticamente con IA"""
    prompt_usuario: str
    agente_objetivo: str
    intencion_detectada: str
    confianza: float
    instrucciones_procesadas: str
    timestamp: str

@dataclass
class RequisitosComplejidad:
    """Define requisitos espec√≠ficos seg√∫n nivel de complejidad"""
    nivel: NivelComplejidad
    descripcion: str
    elementos_obligatorios: List[str]
    elementos_prohibidos: List[str]
    duracion_recomendada: str
    enfoque_pedagogico: str
    nivel_vocabulario: str
    criterios_evaluacion: List[str]

@dataclass
class ContextoRico:
    """Contexto separado del prompt para agentes d√≥ciles"""
    prompt_inicial: str
    materia: str
    tema: Optional[str]
    complejidad: str
    requisitos_complejidad: Optional[RequisitosComplejidad]
    ejemplos_k: Dict[str, str]
    perfiles_estudiantes: List[Dict]
    feedback_acumulado: List[FeedbackInteligente]
    fase_anterior: Optional[str]
    objetivo_fase: str
    quantum_insights: str

@dataclass
class ResultadoValidacion:
    """Resultado de validaci√≥n cu√°ntica"""
    puntuacion: float
    feedback_cuantico: str
    aprobado: bool
    intento: int

@dataclass
class ActividadEducativa:
    """Actividad educativa completa"""
    id: str
    titulo: str
    materia: str
    tema: str
    contenido: str
    estudiantes_objetivo: List[str]
    tipo: str
    adaptaciones: List[str]
    metadatos: Dict
    timestamp: str

# =============================================================================
# TOOLS ESPECIALIZADAS
# =============================================================================

class ValidadorCoherenciaTool(BaseTool):
    """Tool para validaci√≥n de coherencia interna"""
    name: str = "validador_coherencia"
    description: str = "Valida coherencia narrativa y pedag√≥gica de una actividad"
    
    def _run(self, actividad: str) -> str:
        problemas = []
        
        # Validaci√≥n b√°sica de coherencia
        if len(actividad) < 200:
            problemas.append("Actividad demasiado corta, falta profundidad")
        
        # Validaci√≥n de estudiantes
        estudiantes_esperados = ["ALEX M.", "MAR√çA L.", "ELENA R.", "LUIS T.", "ANA V.", "SARA M.", "EMMA K.", "HUGO P."]
        estudiantes_encontrados = sum(1 for est in estudiantes_esperados if est in actividad)
        
        if estudiantes_encontrados < 4:
            problemas.append(f"Solo se mencionan {estudiantes_encontrados}/8 estudiantes reales")
        
        # Validaci√≥n de roles espec√≠ficos
        if "roles espec√≠ficos" not in actividad.lower() and "roles asignados" not in actividad.lower():
            problemas.append("Faltan roles espec√≠ficos para los estudiantes")
        
        if problemas:
            return f"‚ùå PROBLEMAS DE COHERENCIA: {'; '.join(problemas)}"
        return "‚úÖ Coherencia validada correctamente"

class EjemplosKTool(BaseTool):
    """Tool para cargar ejemplos K de referencia"""
    name: str = "ejemplos_k"
    description: str = "Carga ejemplos de actividades exitosas como referencia"
    
    def _run(self, materia: str) -> str:
        ejemplos_map = {
            'matematicas': 'k_sonnet_supermercado',
            'lengua': 'k_piratas', 
            'ciencias': 'k_celula'
        }
        
        ejemplo_key = ejemplos_map.get(materia.lower(), 'k_piratas')
        
        try:
            script_dir = os.path.dirname(os.path.abspath(__file__))
            archivo_path = os.path.join(script_dir, 'actividades_generadas', f'{ejemplo_key}.txt')
            
            if os.path.exists(archivo_path):
                with open(archivo_path, 'r', encoding='utf-8') as f:
                    contenido = f.read()[:800]  # Primeros 800 caracteres
                return f"üìñ EJEMPLO DE CALIDAD:\n{contenido}"
            else:
                return "üìñ Ejemplo gen√©rico: Actividad colaborativa con roles espec√≠ficos, narrativa envolvente y adaptaciones personalizadas"
        except Exception as e:
            return f"üìñ Error cargando ejemplo: {e}"

# =============================================================================
# SISTEMA PRINCIPAL
# =============================================================================

class SistemaAgentesHibridoOptimizado:
    """
    Sistema h√≠brido que combina lo mejor de todos los enfoques anteriores
    """
    
    def __init__(self, 
                 ollama_host: str = "192.168.1.10",
                 modelo_base: str = "qwen3:latest",
                 perfiles_path: str = "perfiles_4_primaria.json"):
        
        self.ollama_host = ollama_host
        self.modelo_base = modelo_base
        self.perfiles_path = perfiles_path
        
        # Inicializaci√≥n de componentes
        self._verificar_modelo_disponible()
        self._configurar_llm()
        self._cargar_recursos()
        self._crear_clasificador_semantico()
        self._crear_agentes_dociles()
        self._crear_quantum_enhancer()
        
        logger.info("‚úÖ Sistema H√≠brido Optimizado inicializado")
        logger.info(f"   ü§ñ Modelo: {self.modelo_base}")
        logger.info(f"   üìñ Ejemplos K: {len(self.ejemplos_k)}")
        logger.info(f"   üë• Estudiantes: {len(self.perfiles_data)}")
    
    def _verificar_modelo_disponible(self):
        """Verifica que el modelo est√© disponible en Ollama"""
        try:
            import requests
            
            # Verificar conexi√≥n con Ollama
            url = f"http://{self.ollama_host}:11434/api/tags"
            response = requests.get(url, timeout=10)
            
            if response.status_code == 200:
                modelos_data = response.json()
                modelos_disponibles = [model['name'] for model in modelos_data.get('models', [])]
                
                logger.info(f"üìã Modelos disponibles en Ollama: {modelos_disponibles}")
                
                # Verificar si nuestro modelo est√° disponible
                if self.modelo_base not in modelos_disponibles:
                    logger.warning(f"‚ö†Ô∏è Modelo '{self.modelo_base}' no encontrado.")
                    logger.warning(f"üí° Modelos disponibles: {modelos_disponibles}")
                    
                    # Sugerir alternativas comunes (basadas en tus modelos disponibles)
                    alternativas = ['qwen3:latest', 'qwen2:latest', 'llama3:latest', 'llama3.2:latest', 'mistral:latest', 'gemma3:latest']
                    disponibles = [alt for alt in alternativas if alt in modelos_disponibles]
                    
                    if disponibles:
                        sugerencia = disponibles[0]
                        logger.info(f"üí° Sugerencia: Usar '{sugerencia}' como alternativa")
                        respuesta = input(f"¬øQuieres usar '{sugerencia}' en lugar de '{self.modelo_base}'? (s/n): ")
                        if respuesta.lower() in ['s', 'si', 's√≠', 'y', 'yes']:
                            self.modelo_base = sugerencia
                            os.environ["OPENAI_MODEL_NAME"] = sugerencia
                            logger.info(f"‚úÖ Modelo cambiado a: {sugerencia}")
                    else:
                        logger.error(f"‚ùå No hay alternativas obvias disponibles")
                        raise Exception(f"Modelo '{self.modelo_base}' no disponible")
                else:
                    logger.info(f"‚úÖ Modelo '{self.modelo_base}' verificado y disponible")
            
            else:
                logger.warning(f"‚ö†Ô∏è No se pudo conectar a Ollama en {self.ollama_host}:11434")
                logger.warning(f"   C√≥digo de estado: {response.status_code}")
                
        except requests.exceptions.RequestException as e:
            logger.warning(f"‚ö†Ô∏è Error verificando modelos en Ollama: {e}")
            logger.warning(f"   Continuando sin verificaci√≥n...")
        except Exception as e:
            logger.error(f"‚ùå Error en verificaci√≥n de modelo: {e}")
            raise e
    
    def _configurar_llm(self):
        """Configura LLM compartido como q_sistema_agentes_2.py"""
        try:
            import litellm
            
            # Configurar litellm para costos
            litellm.model_cost[f"ollama/{self.modelo_base}"] = {
                "input_cost_per_token": 0,
                "output_cost_per_token": 0,
                "max_tokens": 4096
            }
            
            # Crear LLM (EXACTAMENTE igual que q_sistema_agentes_2.py l√≠nea 157-160)
            self.llm = Ollama(
                model=f"ollama/{self.modelo_base}",
                base_url=f"http://{self.ollama_host}:11434"
            )
            
            logger.info(f"‚úÖ LLM configurado: {self.modelo_base}")
            
        except Exception as e:
            logger.error(f"‚ùå Error configurando LLM: {e}")
            raise e
    
    def _cargar_recursos(self):
        """Carga ejemplos K y perfiles de estudiantes"""
        # Cargar ejemplos K
        self.ejemplos_k = {}
        archivos_k = [
            "actividades_generadas/k_celula.txt",
            "actividades_generadas/k_sonnet_supermercado.txt", 
            "actividades_generadas/k_feria_acertijos.txt",
            "actividades_generadas/k_piratas.txt"
        ]
        
        for archivo in archivos_k:
            try:
                script_dir = os.path.dirname(os.path.abspath(__file__))
                archivo_path = os.path.join(script_dir, archivo)
                
                if os.path.exists(archivo_path):
                    with open(archivo_path, 'r', encoding='utf-8') as f:
                        contenido = f.read()
                        nombre_ejemplo = os.path.basename(archivo).replace('.txt', '')
                        self.ejemplos_k[nombre_ejemplo] = contenido
                        logger.info(f"üìñ Cargado: {nombre_ejemplo}")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Error cargando {archivo}: {e}")
        
        # Cargar perfiles de estudiantes
        try:
            script_dir = os.path.dirname(os.path.abspath(__file__))
            perfiles_path = os.path.join(script_dir, self.perfiles_path)
            
            with open(perfiles_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
                self.perfiles_data = data.get('estudiantes', self._crear_perfiles_default())
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error cargando perfiles: {e}")
            self.perfiles_data = self._crear_perfiles_default()
    
    def _crear_perfiles_default(self) -> List[Dict]:
        """Perfiles por defecto"""
        return [
            {"id": "001", "nombre": "ALEX M.", "temperamento": "reflexivo", "canal_preferido": "visual", "diagnostico_formal": "ninguno", "ci_base": 102},
            {"id": "002", "nombre": "MAR√çA L.", "temperamento": "reflexivo", "canal_preferido": "auditivo", "diagnostico_formal": "ninguno"},
            {"id": "003", "nombre": "ELENA R.", "temperamento": "reflexivo", "canal_preferido": "visual", "diagnostico_formal": "TEA_nivel_1", "ci_base": 118},
            {"id": "004", "nombre": "LUIS T.", "temperamento": "impulsivo", "canal_preferido": "kinest√©sico", "diagnostico_formal": "TDAH_combinado", "ci_base": 102},
            {"id": "005", "nombre": "ANA V.", "temperamento": "reflexivo", "canal_preferido": "auditivo", "diagnostico_formal": "altas_capacidades", "ci_base": 141},
            {"id": "006", "nombre": "SARA M.", "temperamento": "equilibrado", "canal_preferido": "auditivo", "diagnostico_formal": "ninguno", "ci_base": 115},
            {"id": "007", "nombre": "EMMA K.", "temperamento": "reflexivo", "canal_preferido": "visual", "diagnostico_formal": "ninguno", "ci_base": 132},
            {"id": "008", "nombre": "HUGO P.", "temperamento": "equilibrado", "canal_preferido": "visual", "diagnostico_formal": "ninguno", "ci_base": 114}
        ]
    
    def _crear_clasificador_semantico(self):
        """Sistema de clasificaci√≥n sem√°ntica usando LLM como clasificador inteligente"""
        
        # Definiciones conceptuales generales (no frases espec√≠ficas)
        self.dominios_conceptuales = {
            "INSPIRADOR": {
                "descripcion": "Maneja creatividad, narrativa, estilo, ambiente, historia y conceptos inspiradores",
                "ejemplos": ["cambiar la historia", "m√°s creativo", "menos fantasioso", "ambiente diferente", "narrativa m√°s realista"]
            },
            "PEDAGOGO": {
                "descripcion": "Maneja objetivos educativos, metodolog√≠a, evaluaci√≥n, competencias y estructura pedag√≥gica",
                "ejemplos": ["objetivos m√°s claros", "cambiar metodolog√≠a", "m√°s riguroso", "competencias espec√≠ficas", "evaluaci√≥n diferente"]
            },
            "ARQUITECTO": {
                "descripcion": "Maneja organizaci√≥n, estructura temporal, flujo de tareas, log√≠stica, distribuci√≥n de trabajo y asignaci√≥n espec√≠fica de roles",
                "ejemplos": ["organizar mejor", "estructurar tareas", "menos tiempo", "qui√©n hace qu√©", "m√°s organizado", "tareas espec√≠ficas", "asignaci√≥n de roles", "tareas adaptadas", "distribuci√≥n del trabajo"]
            },
            "DIFERENCIADOR": {
                "descripcion": "Maneja adaptaciones, personalizaci√≥n, inclusi√≥n y necesidades espec√≠ficas de estudiantes",
                "ejemplos": ["adaptar para TEA", "m√°s inclusivo", "personalizar", "necesidades especiales", "accesibilidad"]
            }
        }
        
        logger.info("‚úÖ Clasificador sem√°ntico inteligente configurado (basado en LLM)")
    
    def _crear_agentes_dociles(self):
        """Crea agentes con prompts minimalistas pero efectivos"""
        
        # Tools compartidas
        self.tools = [
            ValidadorCoherenciaTool(),
            EjemplosKTool()
        ]
        
        # Agente Inspirador - Prompts d√≥ciles (igual que q_sistema_agentes_2.py)
        self.agente_inspirador = Agent(
            role="Creador de Semillas Creativas",
            goal="Crear una semilla creativa inspiradora bas√°ndome en el contexto rico proporcionado",
            backstory="Soy un especialista en narrativas educativas. Adapto ideas seg√∫n feedback espec√≠fico y creo propuestas originales.",
            tools=self.tools,
            llm=self.llm,
            verbose=True,
            allow_delegation=False,
            max_iter=2
        )
        
        # Agente Pedagogo
        self.agente_pedagogo = Agent(
            role="Estructurador Pedag√≥gico",
            goal="Transformar la semilla creativa en estructura pedag√≥gica s√≥lida, incorporando feedback espec√≠fico",
            backstory="Soy un experto curricular. Ajusto metodolog√≠as seg√∫n indicaciones precisas manteniendo rigor acad√©mico.",
            tools=self.tools,
            llm=self.llm,
            verbose=True,
            allow_delegation=False,
            max_iter=2
        )
        
        # Agente Arquitecto
        self.agente_arquitecto = Agent(
            role="Dise√±ador de Experiencias",
            goal="Crear el flujo temporal y arquitectura de la experiencia educativa seg√∫n feedback recibido",
            backstory="Soy un especialista en dise√±o de experiencias. Modifico estructuras seg√∫n feedback espec√≠fico.",
            tools=self.tools,
            llm=self.llm,
            verbose=True,
            allow_delegation=False,
            max_iter=2
        )
        
        # Agente Diferenciador
        self.agente_diferenciador = Agent(
            role="Personalizador Educativo",
            goal="Adaptar la experiencia a cada estudiante seg√∫n perfiles y feedback de inclusi√≥n",
            backstory="Soy un psicopedagogo. Personalizo seg√∫n perfiles espec√≠ficos y feedback de inclusi√≥n.",
            tools=self.tools,
            llm=self.llm,
            verbose=True,
            allow_delegation=False,
            max_iter=2
        )
        
        logger.info("‚úÖ Agentes d√≥ciles creados")
    
    def _crear_quantum_enhancer(self):
        """Inicializa el quantum enhancer para validaci√≥n"""
        try:
            self.quantum_enhancer = QuantumEnhancer(QISKIT_CONFIG)
            logger.info("‚úÖ Quantum Enhancer inicializado")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error inicializando Quantum Enhancer: {e}")
            self.quantum_enhancer = None
    
    def _analizar_feedback_semantico(self, prompt_feedback: str) -> FeedbackInteligente:
        """Analiza feedback usando LLM como clasificador inteligente"""
        
        try:
            # TEMPORAL: Deshabilitar LLM para clasificaci√≥n hasta que funcionen los agentes principales
            # Usar solo clasificaci√≥n fallback
            return self._clasificacion_fallback(prompt_feedback, "LLM temporalmente deshabilitado para debugging")
            
            # Crear prompt para clasificaci√≥n inteligente (DESHABILITADO TEMPORALMENTE)
            prompt_clasificador_disabled = f"""
Analiza este feedback de usuario y determina qu√© agente educativo deber√≠a recibirlo.

FEEDBACK DEL USUARIO: "{prompt_feedback}"

AGENTES DISPONIBLES:

INSPIRADOR: {self.dominios_conceptuales["INSPIRADOR"]["descripcion"]}
Ejemplos: {", ".join(self.dominios_conceptuales["INSPIRADOR"]["ejemplos"])}

PEDAGOGO: {self.dominios_conceptuales["PEDAGOGO"]["descripcion"]}
Ejemplos: {", ".join(self.dominios_conceptuales["PEDAGOGO"]["ejemplos"])}

ARQUITECTO: {self.dominios_conceptuales["ARQUITECTO"]["descripcion"]}
Ejemplos: {", ".join(self.dominios_conceptuales["ARQUITECTO"]["ejemplos"])}

DIFERENCIADOR: {self.dominios_conceptuales["DIFERENCIADOR"]["descripcion"]}
Ejemplos: {", ".join(self.dominios_conceptuales["DIFERENCIADOR"]["ejemplos"])}

INSTRUCCIONES:
1. Analiza el feedback del usuario
2. Determina qu√© agente es m√°s apropiado bas√°ndote en el contenido sem√°ntico
3. Si el feedback abarca m√∫ltiples √°reas, elige el √°rea PRINCIPAL
4. Responde SOLO con una de estas opciones: INSPIRADOR, PEDAGOGO, ARQUITECTO, DIFERENCIADOR

RESPUESTA:"""
            
            # Usar LLM compartido para clasificar
            respuesta_llm = self.llm.invoke(prompt_clasificador).strip().upper()
            
            # Validar respuesta
            agentes_validos = ["INSPIRADOR", "PEDAGOGO", "ARQUITECTO", "DIFERENCIADOR"]
            if respuesta_llm not in agentes_validos:
                logger.warning(f"‚ö†Ô∏è Respuesta LLM inv√°lida: {respuesta_llm}. Usando GENERAL")
                agente_objetivo = "general"
                confianza = 0.3
            else:
                agente_objetivo = respuesta_llm.lower()
                confianza = 0.8  # Alta confianza en LLM
            
            # Generar an√°lisis de intenci√≥n m√°s detallado
            intencion_detectada = self._generar_analisis_intencion(prompt_feedback, agente_objetivo)
            
            # Generar instrucciones espec√≠ficas
            agente_enum = AgenteSemantico(agente_objetivo) if agente_objetivo != "general" else AgenteSemantico.GENERAL
            instrucciones = self._generar_instrucciones_especificas(prompt_feedback, agente_enum)
            
            return FeedbackInteligente(
                prompt_usuario=prompt_feedback,
                agente_objetivo=agente_objetivo,
                intencion_detectada=intencion_detectada,
                confianza=confianza,
                instrucciones_procesadas=instrucciones,
                timestamp=datetime.now().isoformat()
            )
            
        except Exception as e:
            logger.error(f"‚ùå Error en an√°lisis sem√°ntico con LLM: {e}")
            
            # Fallback a clasificaci√≥n simple basada en keywords
            return self._clasificacion_fallback(prompt_feedback, str(e))
    
    def _clasificacion_fallback(self, feedback: str, error: str) -> FeedbackInteligente:
        """Clasificaci√≥n fallback simple cuando LLM falla"""
        
        feedback_lower = feedback.lower()
        
        # Keywords simples para clasificaci√≥n b√°sica
        if any(word in feedback_lower for word in ["tareas", "organizar", "estructura", "quien", "asignar", "roles"]):
            agente_objetivo = "arquitecto"
            confianza = 0.6
        elif any(word in feedback_lower for word in ["historia", "narrativa", "creativo", "art√≠stico", "misterio"]):
            agente_objetivo = "inspirador" 
            confianza = 0.6
        elif any(word in feedback_lower for word in ["objetivos", "pedag√≥gico", "metodolog√≠a", "evaluaci√≥n"]):
            agente_objetivo = "pedagogo"
            confianza = 0.6
        elif any(word in feedback_lower for word in ["adaptar", "TEA", "TDAH", "personalizar", "inclusivo"]):
            agente_objetivo = "diferenciador"
            confianza = 0.6
        else:
            agente_objetivo = "general"
            confianza = 0.3
        
        return FeedbackInteligente(
            prompt_usuario=feedback,
            agente_objetivo=agente_objetivo,
            intencion_detectada=f"Clasificaci√≥n fallback: {agente_objetivo} (LLM no disponible)",
            confianza=confianza,
            instrucciones_procesadas=f"""
üîß FEEDBACK DEL USUARIO (MODO FALLBACK):
"{feedback}"

INSTRUCCIONES:
- El LLM no est√° disponible, usando clasificaci√≥n b√°sica
- Interpreta este feedback seg√∫n tu √°rea de expertise
- Error LLM: {error}
""",
            timestamp=datetime.now().isoformat()
        )
    
    def _generar_analisis_intencion(self, feedback: str, agente_objetivo: str) -> str:
        """Genera an√°lisis de intenci√≥n m√°s detallado usando LLM"""
        
        try:
            prompt_intencion = f"""
Analiza la intenci√≥n espec√≠fica de este feedback educativo:

FEEDBACK: "{feedback}"
AGENTE ASIGNADO: {agente_objetivo.upper()}

Genera un resumen breve (1 l√≠nea) de qu√© quiere cambiar o mejorar el usuario espec√≠ficamente.

FORMATO: "El usuario quiere [acci√≥n espec√≠fica] para [objetivo]"

RESPUESTA:"""
            
            # Usar LLM compartido para an√°lisis de intenci√≥n
            respuesta = self.llm.invoke(prompt_intencion).strip()
            return respuesta if respuesta else f"Modificar {agente_objetivo} seg√∫n feedback del usuario"
            
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error generando an√°lisis de intenci√≥n: {e}")
            return f"Modificar {agente_objetivo} - an√°lisis autom√°tico"
    
    def _generar_instrucciones_especificas(self, prompt: str, agente: AgenteSemantico) -> str:
        """Genera instrucciones espec√≠ficas por agente"""
        
        plantillas = {
            AgenteSemantico.INSPIRADOR: f"""
üé≠ FEEDBACK DEL USUARIO PARA CREATIVIDAD E INSPIRACI√ìN:
"{prompt}"

INSTRUCCIONES:
- Interpreta este feedback y apl√≠calo a los aspectos creativos, narrativos o inspiradores
- Mant√©n coherencia general pero prioriza la solicitud del usuario
- Adapta seg√∫n el contexto espec√≠fico de la actividad
""",
            AgenteSemantico.PEDAGOGO: f"""
üìö FEEDBACK DEL USUARIO PARA PEDAGOG√çA:
"{prompt}"

INSTRUCCIONES:
- Interpreta este feedback y apl√≠calo a los aspectos pedag√≥gicos y metodol√≥gicos
- Ajusta seg√∫n las necesidades educativas mencionadas
- Mant√©n rigor acad√©mico apropiado para el nivel
""",
            AgenteSemantico.ARQUITECTO: f"""
üèóÔ∏è FEEDBACK DEL USUARIO PARA ORGANIZACI√ìN:
"{prompt}"

INSTRUCCIONES:
- Interpreta este feedback y apl√≠calo a la organizaci√≥n, estructura y flujo de tareas
- Reorganiza seg√∫n las necesidades de timing y log√≠stica mencionadas
- Mant√©n coherencia en la experiencia general
""",
            AgenteSemantico.DIFERENCIADOR: f"""
üéØ FEEDBACK DEL USUARIO PARA PERSONALIZACI√ìN:
"{prompt}"

INSTRUCCIONES:
- Interpreta este feedback y apl√≠calo a las adaptaciones y personalizaci√≥n
- Ajusta seg√∫n las necesidades de inclusi√≥n o diferenciaci√≥n mencionadas
- Mant√©n accesibilidad para todos los estudiantes
""",
            AgenteSemantico.GENERAL: f"""
üîß FEEDBACK GENERAL DEL USUARIO:
"{prompt}"

INSTRUCCIONES:
- Interpreta este feedback seg√∫n tu √°rea de expertise espec√≠fica
- Aplica los cambios de manera apropiada para tu rol
- Mant√©n coherencia con el objetivo general de la actividad
"""
        }
        
        return plantillas.get(agente, plantillas[AgenteSemantico.GENERAL])
    
    def _construir_contexto_rico(self, 
                                prompt_inicial: str,
                                materia: str,
                                tema: Optional[str],
                                complejidad: str,
                                requisitos_complejidad: Optional[RequisitosComplejidad],
                                fase_anterior: Optional[str],
                                objetivo_fase: str,
                                feedback_acumulado: List[FeedbackInteligente],
                                quantum_insights: str = "") -> ContextoRico:
        """Construye contexto rico separado para compensar prompts minimalistas"""
        
        # Seleccionar ejemplos K relevantes
        ejemplos_relevantes = {}
        if materia.lower() in ['matematicas', 'mates']:
            for key in ['k_sonnet_supermercado', 'k_feria_acertijos']:
                if key in self.ejemplos_k:
                    ejemplos_relevantes[key] = self.ejemplos_k[key][:1000]
        elif materia.lower() in ['ciencias', 'naturales']:
            if 'k_celula' in self.ejemplos_k:
                ejemplos_relevantes['k_celula'] = self.ejemplos_k['k_celula'][:1000]
        elif materia.lower() in ['lengua', 'lenguaje']:
            if 'k_piratas' in self.ejemplos_k:
                ejemplos_relevantes['k_piratas'] = self.ejemplos_k['k_piratas'][:1000]
        
        # Si no hay ejemplos espec√≠ficos, usar uno gen√©rico
        if not ejemplos_relevantes and 'k_piratas' in self.ejemplos_k:
            ejemplos_relevantes['k_piratas'] = self.ejemplos_k['k_piratas'][:1000]
        
        return ContextoRico(
            prompt_inicial=prompt_inicial,
            materia=materia,
            tema=tema,
            complejidad=complejidad,
            requisitos_complejidad=requisitos_complejidad,
            ejemplos_k=ejemplos_relevantes,
            perfiles_estudiantes=self.perfiles_data,
            feedback_acumulado=feedback_acumulado,
            fase_anterior=fase_anterior,
            objetivo_fase=objetivo_fase,
            quantum_insights=quantum_insights
        )
    
    def _crear_contexto_texto(self, contexto_rico: ContextoRico) -> str:
        """Convierte ContextoRico en texto estructurado para el LLM"""
        
        contexto_texto = f"""
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
CONTEXTO RICO PARA AGENTE D√ìCIL
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

PROMPT INICIAL DEL USUARIO:
{contexto_rico.prompt_inicial}

INFORMACI√ìN B√ÅSICA:
- Materia: {contexto_rico.materia}
- Tema: {contexto_rico.tema or 'General'}
- Complejidad solicitada: {contexto_rico.complejidad}
- Objetivo de esta fase: {contexto_rico.objetivo_fase}

REQUISITOS DE COMPLEJIDAD {contexto_rico.requisitos_complejidad.nivel.value.upper() if contexto_rico.requisitos_complejidad else 'NO ESPECIFICADO'}:
{f"- Duraci√≥n: {contexto_rico.requisitos_complejidad.duracion_recomendada}" if contexto_rico.requisitos_complejidad else ""}
{f"- Enfoque pedag√≥gico: {contexto_rico.requisitos_complejidad.enfoque_pedagogico}" if contexto_rico.requisitos_complejidad else ""}
{f"- Nivel de vocabulario: {contexto_rico.requisitos_complejidad.nivel_vocabulario}" if contexto_rico.requisitos_complejidad else ""}

ELEMENTOS OBLIGATORIOS PARA ESTE NIVEL:
{chr(10).join([f"‚úÖ {elem}" for elem in contexto_rico.requisitos_complejidad.elementos_obligatorios]) if contexto_rico.requisitos_complejidad else "No especificado"}

ELEMENTOS PROHIBIDOS PARA ESTE NIVEL:
{chr(10).join([f"‚ùå {elem}" for elem in contexto_rico.requisitos_complejidad.elementos_prohibidos]) if contexto_rico.requisitos_complejidad else "No especificado"}

CRITERIOS DE EVALUACI√ìN ESPERADOS:
{chr(10).join([f"üéØ {crit}" for crit in contexto_rico.requisitos_complejidad.criterios_evaluacion]) if contexto_rico.requisitos_complejidad else "No especificado"}

{f"INSIGHTS CU√ÅNTICOS PRE-PROCESADOS:{chr(10)}{contexto_rico.quantum_insights}" if contexto_rico.quantum_insights else ""}

EJEMPLOS DE CALIDAD K_ PARA INSPIRACI√ìN:
"""
        
        for nombre, contenido in contexto_rico.ejemplos_k.items():
            contexto_texto += f"\n--- {nombre.upper()} ---\n{contenido}\n"
        
        contexto_texto += f"""
ESTUDIANTES REALES DEL AULA (USAR EXACTAMENTE ESTOS):
"""
        for estudiante in contexto_rico.perfiles_estudiantes:
            contexto_texto += f"- {estudiante['id']} {estudiante['nombre']}: {estudiante.get('temperamento', 'N/A')}, {estudiante.get('canal_preferido', 'N/A')}"
            if estudiante.get('diagnostico_formal', 'ninguno') != 'ninguno':
                contexto_texto += f", {estudiante['diagnostico_formal']}"
            contexto_texto += "\n"
        
        if contexto_rico.fase_anterior:
            contexto_texto += f"\nFASE ANTERIOR COMPLETADA: {contexto_rico.fase_anterior}"
        
        # Feedback acumulado
        if contexto_rico.feedback_acumulado:
            contexto_texto += f"\n\nFEEDBACK ACUMULADO DEL USUARIO:\n"
            for i, feedback in enumerate(contexto_rico.feedback_acumulado, 1):
                contexto_texto += f"{i}. [{feedback.agente_objetivo.upper()}] {feedback.prompt_usuario}\n"
                contexto_texto += f"   Instrucciones: {feedback.instrucciones_procesadas}\n"
        
        contexto_texto += f"""
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
INSTRUCCIONES FINALES:
- Usa EXACTAMENTE los 8 estudiantes listados arriba
- Insp√≠rate en los ejemplos K_ pero crea algo NUEVO
- Si hay feedback del usuario, es PRIORIDAD M√ÅXIMA
- Mant√©n coherencia con el prompt inicial
- Crea contenido apropiado para 4¬∫ Primaria
- ADAPTA LA COMPLEJIDAD seg√∫n el nivel solicitado: {contexto_rico.complejidad}
- Ajusta vocabulario, conceptos y actividades al nivel de complejidad indicado
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
"""
        
        return contexto_texto
    
    def _validar_con_quantum_enhancer(self, actividad: str, materia: str, tema: str, intento: int) -> ResultadoValidacion:
        """Valida actividad usando quantum enhancer"""
        if not self.quantum_enhancer:
            return ResultadoValidacion(0.8, "Validaci√≥n cu√°ntica no disponible", True, intento)
        
        try:
            puntuacion, feedback = self.quantum_enhancer.validar_actividad_cuanticamente(
                actividad, materia, tema
            )
            
            aprobado = puntuacion >= self.quantum_enhancer.UMBRAL_VALIDACION_CUANTICA
            
            return ResultadoValidacion(puntuacion, feedback, aprobado, intento)
            
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error en validaci√≥n cu√°ntica: {e}")
            return ResultadoValidacion(0.8, f"Error en validaci√≥n: {e}", True, intento)
    
    def _solicitar_feedback_inteligente(self, fase: str, contenido_previo: str) -> List[FeedbackInteligente]:
        """Solicita feedback usando sistema sem√°ntico inteligente"""
        
        print(f"\n" + "="*70)
        print(f"üß† FEEDBACK SEM√ÅNTICO INTELIGENTE - {fase.upper()}")
        print("="*70)
        
        # Mostrar resumen del contenido
        lineas = contenido_previo.split('\n')[:6]
        for linea in lineas:
            if linea.strip():
                print(f"üìÑ {linea[:65]}{'...' if len(linea) > 65 else ''}")
        
        print(f"\n‚ùì ¬øQu√© quieres cambiar o mejorar de esta {fase}?")
        print("üí° Puedes escribir en lenguaje natural:")
        print("   ‚Ä¢ 'Hazlo m√°s din√°mico y corto'")
        print("   ‚Ä¢ 'Adapta mejor para estudiantes con TEA'") 
        print("   ‚Ä¢ 'Cambia la historia por algo m√°s realista'")
        print("   ‚Ä¢ 'Reorganiza las fases temporales'")
        print("\n1. ‚úÖ Perfecto, contin√∫a sin cambios")
        print("2. üí¨ Dar feedback en lenguaje natural")
        
        while True:
            try:
                opcion = input("\nüëâ Selecciona (1-2): ").strip()
                
                if opcion == "1":
                    print("‚úÖ Continuando sin cambios...")
                    return []
                elif opcion == "2":
                    break
                else:
                    print("‚ùå Por favor, selecciona 1 o 2")
            except KeyboardInterrupt:
                print("\n‚ùå Proceso cancelado")
                return []
        
        feedback_list = []
        
        while True:
            print(f"\nüí¨ Escribe tu feedback (o 'fin' para terminar):")
            try:
                prompt_feedback = input("üó£Ô∏è Tu feedback: ").strip()
                
                if prompt_feedback.lower() in ['fin', 'terminar', 'listo', 'ya']:
                    break
                
                if not prompt_feedback:
                    print("‚ùå Por favor, escribe algo o 'fin' para terminar")
                    continue
                
                # An√°lisis sem√°ntico autom√°tico
                feedback_analizado = self._analizar_feedback_semantico(prompt_feedback)
                
                # Mostrar an√°lisis
                print(f"\nüß† AN√ÅLISIS AUTOM√ÅTICO:")
                print(f"   üéØ Agente objetivo: {feedback_analizado.agente_objetivo}")
                print(f"   üéØ Confianza: {feedback_analizado.confianza:.1%}")
                print(f"   üéØ Intenci√≥n: {feedback_analizado.intencion_detectada}")
                
                # Confirmar
                confirmar = input(f"\n¬øEs correcto? (s/n): ").strip().lower()
                if confirmar in ['s', 'si', 's√≠', 'yes', 'y', '']:
                    feedback_list.append(feedback_analizado)
                    print(f"‚úÖ Feedback agregado para {feedback_analizado.agente_objetivo}")
                else:
                    print("‚ùå Feedback descartado. Puedes intentar con otras palabras.")
                
            except KeyboardInterrupt:
                print("\n‚ùå Proceso cancelado")
                break
            except Exception as e:
                print(f"‚ùå Error procesando feedback: {e}")
                continue
        
        if feedback_list:
            print(f"\n‚úÖ {len(feedback_list)} feedback(s) procesado(s)")
        
        return feedback_list
    
    def _aplicar_feedback_a_agente(self, feedback_list: List[FeedbackInteligente], agente_actual: str) -> str:
        """Aplica feedback relevante al agente actual"""
        
        if not feedback_list:
            return ""
        
        # Filtrar feedback relevante
        feedback_relevante = [f for f in feedback_list 
                             if f.agente_objetivo == agente_actual or f.agente_objetivo == "general"]
        
        # Propagaci√≥n cr√≠tica: feedback de arquitectura a todos
        feedback_arquitectura = [f for f in feedback_list if f.agente_objetivo == "arquitecto"]
        if feedback_arquitectura and agente_actual != "arquitecto":
            for fb in feedback_arquitectura:
                if any(keyword in fb.prompt_usuario.lower() 
                       for keyword in ["semana", "d√≠a", "duraci√≥n", "tiempo", "organizar"]):
                    feedback_relevante.append(fb)
        
        if not feedback_relevante:
            return ""
        
        instrucciones = "\nüéØ FEEDBACK ESPEC√çFICO DEL USUARIO (PRIORIDAD M√ÅXIMA):\n"
        for i, feedback in enumerate(feedback_relevante, 1):
            if feedback.agente_objetivo == "arquitecto" and agente_actual != "arquitecto":
                instrucciones += f"\n{i}. üïê DURACI√ìN/TIEMPO CR√çTICO: {feedback.prompt_usuario}\n"
                instrucciones += f"   ‚Üí APLICA esta consideraci√≥n temporal en tu secci√≥n\n"
            else:
                instrucciones += f"\n{i}. {feedback.instrucciones_procesadas}\n"
        
        instrucciones += "\n‚ö†Ô∏è ESTAS INSTRUCCIONES TIENEN PRIORIDAD ABSOLUTA.\n"
        
        return instrucciones
    
    def _detectar_materia_y_tema(self, prompt: str) -> Tuple[str, Optional[str]]:
        """Detecta autom√°ticamente materia y tema del prompt"""
        
        prompt_lower = prompt.lower()
        
        # Detectar materia
        materias = {
            'matematicas': ['matem√°ticas', 'mates', 'n√∫meros', 'c√°lculo', 'geometr√≠a', 'fracciones', 'suma', 'resta'],
            'lengua': ['lengua', 'idioma', 'escritura', 'lectura', 'gram√°tica', 'literatura', 'texto', 'palabras'],
            'ciencias': ['ciencias', 'biolog√≠a', 'f√≠sica', 'qu√≠mica', 'naturales', 'cient√≠fico', 'c√©lulas', 'animales', 'plantas']
        }
        
        materia_detectada = None
        for materia, keywords in materias.items():
            if any(keyword in prompt_lower for keyword in keywords):
                materia_detectada = materia
                break
        
        # Detectar tema
        tema_patterns = [
            r'sobre[:\s]*([^.,\n]+)',
            r'tema[:\s]*([^.,\n]+)', 
            r'acerca de[:\s]*([^.,\n]+)',
            r'de[:\s]+([^.,\n]+)'
        ]
        
        tema_detectado = None
        for pattern in tema_patterns:
            match = re.search(pattern, prompt_lower)
            if match:
                tema_detectado = match.group(1).strip()
                break
        
        return materia_detectada, tema_detectado
    
    def _obtener_requisitos_complejidad(self, nivel: str) -> RequisitosComplejidad:
        """Obtiene requisitos espec√≠ficos seg√∫n nivel de complejidad"""
        
        requisitos_por_nivel = {
            "b√°sica": RequisitosComplejidad(
                nivel=NivelComplejidad.BASICA,
                descripcion="Conceptos fundamentales con actividades simples y directas",
                elementos_obligatorios=[
                    "Vocabulario simple y claro apropiado para 4¬∫ primaria",
                    "Instrucciones paso a paso muy detalladas",
                    "Ejemplos concretos y familiares",
                    "Actividades con objetivos claros y medibles",
                    "Roles simples y bien definidos para cada estudiante",
                    "Evaluaci√≥n directa y observable"
                ],
                elementos_prohibidos=[
                    "Conceptos abstractos complejos",
                    "Vocabulario t√©cnico sin explicaci√≥n",
                    "Tareas abiertas sin gu√≠a",
                    "M√∫ltiples objetivos simult√°neos",
                    "An√°lisis profundo o reflexi√≥n compleja"
                ],
                duracion_recomendada="1-2 sesiones de 45 minutos",
                enfoque_pedagogico="Aprendizaje directo con pr√°ctica guiada",
                nivel_vocabulario="B√°sico de 4¬∫ primaria con explicaciones claras",
                criterios_evaluacion=[
                    "Comprensi√≥n de conceptos b√°sicos",
                    "Participaci√≥n activa en actividades",
                    "Completitud de tareas asignadas"
                ]
            ),
            
            "intermedia": RequisitosComplejidad(
                nivel=NivelComplejidad.INTERMEDIA,
                descripcion="Conceptos con aplicaci√≥n pr√°ctica y actividades moderadamente complejas",
                elementos_obligatorios=[
                    "Vocabulario apropiado con algunos t√©rminos nuevos explicados",
                    "Combinaci√≥n de trabajo individual y colaborativo",
                    "Aplicaci√≥n pr√°ctica de conceptos",
                    "Conexiones entre ideas y conocimiento previo",
                    "Roles diferenciados y rotativos",
                    "Evaluaci√≥n formativa y sumativa"
                ],
                elementos_prohibidos=[
                    "Simplificaci√≥n excesiva",
                    "Conceptos demasiado abstractos",
                    "Tareas repetitivas sin desaf√≠o",
                    "Evaluaci√≥n √∫nicamente memor√≠stica"
                ],
                duracion_recomendada="2-3 sesiones de 45 minutos",
                enfoque_pedagogico="Aprendizaje constructivo con aplicaci√≥n pr√°ctica",
                nivel_vocabulario="Intermedio con introducci√≥n de t√©rminos t√©cnicos",
                criterios_evaluacion=[
                    "Aplicaci√≥n correcta de conceptos",
                    "Colaboraci√≥n efectiva en grupo",
                    "Transferencia de aprendizaje a nuevas situaciones"
                ]
            ),
            
            "avanzada": RequisitosComplejidad(
                nivel=NivelComplejidad.AVANZADA,
                descripcion="Conceptos complejos con actividades desafiantes que requieren pensamiento cr√≠tico",
                elementos_obligatorios=[
                    "Vocabulario t√©cnico apropiado con definiciones",
                    "An√°lisis y s√≠ntesis de informaci√≥n",
                    "Resoluci√≥n de problemas complejos",
                    "Argumentaci√≥n y justificaci√≥n de ideas",
                    "Roles especializados y liderazgo rotativo",
                    "Autoevaluaci√≥n y evaluaci√≥n entre pares"
                ],
                elementos_prohibidos=[
                    "Instrucciones demasiado directivas",
                    "Respuestas √∫nicas o cerradas",
                    "Falta de desaf√≠o intelectual",
                    "Simplificaci√≥n excesiva de conceptos"
                ],
                duracion_recomendada="3-4 sesiones de 45 minutos",
                enfoque_pedagogico="Aprendizaje por indagaci√≥n con pensamiento cr√≠tico",
                nivel_vocabulario="Avanzado con terminolog√≠a especializada",
                criterios_evaluacion=[
                    "An√°lisis cr√≠tico de informaci√≥n",
                    "Argumentaci√≥n fundamentada",
                    "Innovaci√≥n en soluciones propuestas",
                    "Liderazgo en trabajo colaborativo"
                ]
            ),
            
            "experta": RequisitosComplejidad(
                nivel=NivelComplejidad.EXPERTA,
                descripcion="M√°xima complejidad con actividades muy desafiantes y an√°lisis profundo",
                elementos_obligatorios=[
                    "Vocabulario especializado y t√©cnico",
                    "Investigaci√≥n independiente y dirigida",
                    "S√≠ntesis de m√∫ltiples fuentes de informaci√≥n",
                    "Creaci√≥n de productos originales",
                    "Metacognici√≥n y reflexi√≥n profunda",
                    "Evaluaci√≥n multidimensional y aut√≥noma"
                ],
                elementos_prohibidos=[
                    "Actividades rutinarias o mec√°nicas",
                    "Instrucciones excesivamente guiadas",
                    "Falta de oportunidades para innovaci√≥n",
                    "Evaluaci√≥n superficial"
                ],
                duracion_recomendada="1 semana (4-5 sesiones)",
                enfoque_pedagogico="Aprendizaje aut√≥nomo con mentor√≠a especializada",
                nivel_vocabulario="Experto con terminolog√≠a acad√©mica",
                criterios_evaluacion=[
                    "Originalidad en enfoques y soluciones",
                    "Profundidad de an√°lisis y reflexi√≥n",
                    "Capacidad de s√≠ntesis interdisciplinaria",
                    "Liderazgo intelectual y creatividad"
                ]
            )
        }
        
        return requisitos_por_nivel.get(nivel, requisitos_por_nivel["intermedia"])
    
    def _solicitar_complejidad(self) -> tuple[str, RequisitosComplejidad]:
        """Solicita el nivel de complejidad de la actividad"""
        
        print(f"\n" + "="*60)
        print(f"üéöÔ∏è SELECCI√ìN DE COMPLEJIDAD DE LA ACTIVIDAD")
        print("="*60)
        
        print("Selecciona el nivel de complejidad para la actividad:")
        print("1. üü¢ B√ÅSICA - Conceptos fundamentales, actividades simples")
        print("2. üü° INTERMEDIA - Conceptos con aplicaci√≥n, actividades moderadas")  
        print("3. üî¥ AVANZADA - Conceptos complejos, actividades desafiantes")
        print("4. üèÜ EXPERTA - M√°xima complejidad, actividades muy desafiantes")
        
        complejidades = {
            "1": ("b√°sica", "Conceptos fundamentales con actividades simples y directas"),
            "2": ("intermedia", "Conceptos con aplicaci√≥n pr√°ctica y actividades moderadamente complejas"),
            "3": ("avanzada", "Conceptos complejos con actividades desafiantes que requieren pensamiento cr√≠tico"),
            "4": ("experta", "M√°xima complejidad con actividades muy desafiantes y an√°lisis profundo")
        }
        
        while True:
            try:
                opcion = input("\nüëâ Selecciona complejidad (1-4): ").strip()
                
                if opcion in complejidades:
                    nivel, descripcion = complejidades[opcion]
                    requisitos = self._obtener_requisitos_complejidad(nivel)
                    
                    print(f"‚úÖ Complejidad seleccionada: {nivel.upper()}")
                    print(f"üìù {descripcion}")
                    print(f"‚è±Ô∏è Duraci√≥n: {requisitos.duracion_recomendada}")
                    print(f"üéØ Enfoque: {requisitos.enfoque_pedagogico}")
                    
                    return f"{nivel} - {descripcion}", requisitos
                else:
                    print("‚ùå Por favor, selecciona una opci√≥n v√°lida (1-4)")
                    
            except KeyboardInterrupt:
                print("\n‚ùå Proceso cancelado. Usando complejidad intermedia por defecto.")
                requisitos_default = self._obtener_requisitos_complejidad("intermedia")
                return "intermedia - Conceptos con aplicaci√≥n pr√°ctica y actividades moderadamente complejas", requisitos_default
            except Exception as e:
                print(f"‚ùå Error en selecci√≥n: {e}")
                continue
    
    def generar_actividad_hibrida_optimizada(self, prompt_inicial: str) -> ActividadEducativa:
        """
        M√©todo principal que genera actividad usando el sistema h√≠brido optimizado
        """
        
        logger.info("üöÄ Iniciando generaci√≥n h√≠brida optimizada")
        
        # 1. DETECCI√ìN AUTOM√ÅTICA
        materia, tema = self._detectar_materia_y_tema(prompt_inicial)
        
        if not materia:
            materia = input("üìö ¬øQu√© materia? (matematicas/lengua/ciencias): ").strip().lower()
        
        print(f"\nüéØ Materia detectada: {materia}")
        print(f"üéØ Tema detectado: {tema or 'General'}")
        
        # 2. SELECCI√ìN DE COMPLEJIDAD
        complejidad, requisitos_complejidad = self._solicitar_complejidad()
        
        try:
            feedback_acumulado = []
            resultados = {}
            
            # 2. PREPROCESADO CU√ÅNTICO (si est√° disponible)
            quantum_insights = ""
            if self.quantum_enhancer:
                quantum_insights = self.quantum_enhancer.analizar_dificultad_cuantica(
                    materia, tema, ""
                )
                logger.info(f"‚ú® Insights cu√°nticos: {quantum_insights}")
            
            # ========================================================
            # FASE 1: INSPIRACI√ìN
            # ========================================================
            print(f"\nüé≠ FASE 1: INSPIRACI√ìN")
            
            contexto_inspiracion = self._construir_contexto_rico(
                prompt_inicial, materia, tema, complejidad, requisitos_complejidad, None,
                "Crear semilla creativa inspiradora", feedback_acumulado, quantum_insights
            )
            
            # Retry con validaci√≥n cu√°ntica para inspiraci√≥n
            for intento in range(3):
                print(f"   üîÑ Intento {intento + 1}/3")
                
                tarea_inspiracion = Task(
                    description=f"""
{self._crear_contexto_texto(contexto_inspiracion)}

TAREA ESPEC√çFICA:
Como Creador de Semillas Creativas, genera una semilla creativa inspiradora para esta actividad educativa.
Utiliza el contexto rico proporcionado para crear una propuesta original y motivadora.
Insp√≠rate en los ejemplos K_ pero crea algo NUEVO basado en el prompt inicial del usuario.
                    """,
                    agent=self.agente_inspirador,
                    expected_output="Semilla creativa inspiradora para la actividad educativa"
                )
                
                crew_inspiracion = Crew(
                    agents=[self.agente_inspirador],
                    tasks=[tarea_inspiracion],
                    process=Process.sequential,
                    verbose=False
                )
                
                resultado_inspiracion = crew_inspiracion.kickoff()
                
                # Validaci√≥n cu√°ntica
                validacion = self._validar_con_quantum_enhancer(
                    str(resultado_inspiracion), materia, tema or "general", intento + 1
                )
                
                if validacion.aprobado:
                    print(f"   ‚úÖ Validaci√≥n cu√°ntica aprobada (puntuaci√≥n: {validacion.puntuacion:.2f})")
                    break
                else:
                    print(f"   ‚ùå Validaci√≥n fallida (puntuaci√≥n: {validacion.puntuacion:.2f})")
                    if intento < 2:
                        print(f"   üîÑ Reintentando con feedback cu√°ntico...")
                        # Agregar feedback cu√°ntico al contexto
                        contexto_inspiracion.quantum_insights += f"\n\nFEEDBACK CU√ÅNTICO: {validacion.feedback_cuantico}"
            
            resultados['inspiracion'] = str(resultado_inspiracion)
            
            # Solicitar feedback humano
            feedback_inspiracion = self._solicitar_feedback_inteligente("inspiraci√≥n", str(resultado_inspiracion))
            feedback_acumulado.extend(feedback_inspiracion)
            
            # ========================================================
            # FASE 2: PEDAGOG√çA
            # ========================================================
            print(f"\nüìö FASE 2: PEDAGOG√çA")
            
            contexto_pedagogia = self._construir_contexto_rico(
                prompt_inicial, materia, tema, complejidad, requisitos_complejidad, "inspiraci√≥n",
                "Estructurar pedag√≥gicamente la semilla creativa", feedback_acumulado, quantum_insights
            )
            
            contexto_pedagogia_texto = f"""
RESULTADO DE LA FASE ANTERIOR (INSPIRACI√ìN):
{str(resultado_inspiracion)}

{self._crear_contexto_texto(contexto_pedagogia)}
"""
            
            tarea_pedagogia = Task(
                description=f"""
{contexto_pedagogia_texto}

{self._aplicar_feedback_a_agente(feedback_acumulado, "pedagogo")}

TAREA ESPEC√çFICA:
Como Estructurador Pedag√≥gico, toma la semilla creativa anterior y desarr√≥llala en una estructura pedag√≥gica s√≥lida.
Si hay instrucciones espec√≠ficas del usuario, dales prioridad absoluta.
NO repitas el contenido anterior, sino que MEJORA y ESTRUCTURA la propuesta.
                """,
                agent=self.agente_pedagogo,
                expected_output="Estructura pedag√≥gica mejorada basada en la semilla creativa anterior"
            )
            
            crew_pedagogia = Crew(
                agents=[self.agente_pedagogo],
                tasks=[tarea_pedagogia],
                process=Process.sequential,
                verbose=False
            )
            
            resultado_pedagogia = crew_pedagogia.kickoff()
            resultados['pedagogia'] = str(resultado_pedagogia)
            
            # Feedback humano
            feedback_pedagogia = self._solicitar_feedback_inteligente("estructura pedag√≥gica", str(resultado_pedagogia))
            feedback_acumulado.extend(feedback_pedagogia)
            
            # ========================================================
            # FASE 3: ARQUITECTURA
            # ========================================================
            print(f"\nüèóÔ∏è FASE 3: ARQUITECTURA")
            
            contexto_arquitectura = self._construir_contexto_rico(
                prompt_inicial, materia, tema, complejidad, requisitos_complejidad, "pedagog√≠a",
                "Dise√±ar arquitectura temporal y experiencial", feedback_acumulado, quantum_insights
            )
            
            contexto_arquitectura_texto = f"""
RESULTADO DE LA FASE ANTERIOR (PEDAGOG√çA):
{str(resultado_pedagogia)}

{self._crear_contexto_texto(contexto_arquitectura)}
"""
            
            tarea_arquitectura = Task(
                description=f"""
{contexto_arquitectura_texto}

{self._aplicar_feedback_a_agente(feedback_acumulado, "arquitecto")}

TAREA ESPEC√çFICA:
Como Dise√±ador de Experiencias, toma la estructura pedag√≥gica anterior y crea el flujo temporal y arquitectura de la experiencia.
Si hay instrucciones espec√≠ficas del usuario, dales prioridad absoluta.
NO repitas el contenido anterior, sino que DISE√ëA la experiencia temporal y log√≠stica.
                """,
                agent=self.agente_arquitecto,
                expected_output="Dise√±o de experiencia temporal basado en la estructura pedag√≥gica anterior"
            )
            
            crew_arquitectura = Crew(
                agents=[self.agente_arquitecto],
                tasks=[tarea_arquitectura],
                process=Process.sequential,
                verbose=False
            )
            
            resultado_arquitectura = crew_arquitectura.kickoff()
            resultados['arquitectura'] = str(resultado_arquitectura)
            
            # Feedback humano
            feedback_arquitectura = self._solicitar_feedback_inteligente("arquitectura", str(resultado_arquitectura))
            feedback_acumulado.extend(feedback_arquitectura)
            
            # ========================================================
            # FASE 4: DIFERENCIACI√ìN (FINAL)
            # ========================================================
            print(f"\nüéØ FASE 4: DIFERENCIACI√ìN")
            
            contexto_diferenciacion = self._construir_contexto_rico(
                prompt_inicial, materia, tema, complejidad, requisitos_complejidad, "arquitectura",
                "Personalizar para cada estudiante espec√≠fico", feedback_acumulado, quantum_insights
            )
            
            contexto_diferenciacion_texto = f"""
RESULTADO DE LA FASE ANTERIOR (ARQUITECTURA):
{str(resultado_arquitectura)}

{self._crear_contexto_texto(contexto_diferenciacion)}
"""
            
            tarea_diferenciacion = Task(
                description=f"""
{contexto_diferenciacion_texto}

{self._aplicar_feedback_a_agente(feedback_acumulado, "diferenciador")}

TAREA ESPEC√çFICA:
Como Personalizador Educativo, toma la arquitectura de experiencia anterior y personal√≠zala para cada estudiante espec√≠fico.
Si hay instrucciones espec√≠ficas del usuario, dales prioridad absoluta.
NO repitas el contenido anterior, sino que PERSONALIZA la experiencia para cada estudiante del aula.
                """,
                agent=self.agente_diferenciador,
                expected_output="Actividad personalizada para cada estudiante basada en la arquitectura anterior"
            )
            
            crew_diferenciacion = Crew(
                agents=[self.agente_diferenciador],
                tasks=[tarea_diferenciacion],
                process=Process.sequential,
                verbose=False
            )
            
            resultado_diferenciacion = crew_diferenciacion.kickoff()
            resultados['diferenciacion'] = str(resultado_diferenciacion)
            
            # ========================================================
            # VALIDACI√ìN FINAL Y CONSTRUCCI√ìN
            # ========================================================
            
            # Validaci√≥n cu√°ntica final
            contenido_completo = self._construir_contenido_final(resultados, feedback_acumulado, quantum_insights)
            
            validacion_final = self._validar_con_quantum_enhancer(
                contenido_completo, materia, tema or "general", 1
            )
            
            print(f"\n‚úÖ VALIDACI√ìN FINAL: {validacion_final.puntuacion:.2f}")
            print(f"üìù {validacion_final.feedback_cuantico}")
            
            return ActividadEducativa(
                id=f"hibrido_opt_{materia.lower()}_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                titulo=f"Actividad H√≠brida Optimizada - {materia.title()}",
                materia=materia,
                tema=tema or "tema general",
                contenido=contenido_completo,
                estudiantes_objetivo=["001", "002", "003", "004", "005", "006", "007", "008"],
                tipo="hibrido_optimizado",
                adaptaciones=["feedback_semantico", "validacion_cuantica", "contexto_rico", "agentes_dociles"],
                metadatos={
                    "total_estudiantes": 8,
                    "complejidad": complejidad,
                    "feedback_aplicado": len(feedback_acumulado),
                    "feedback_detalles": [
                        {
                            "agente": f.agente_objetivo,
                            "prompt": f.prompt_usuario,
                            "confianza": f.confianza,
                            "intencion": f.intencion_detectada
                        } for f in feedback_acumulado
                    ],
                    "quantum_insights": quantum_insights,
                    "validacion_final": {
                        "puntuacion": validacion_final.puntuacion,
                        "feedback": validacion_final.feedback_cuantico,
                        "aprobado": validacion_final.aprobado
                    },
                    "modelo_usado": self.modelo_base,
                    "ejemplos_k_usados": list(self.ejemplos_k.keys()),
                    "version": "hibrido_optimizado_1.0"
                },
                timestamp=datetime.now().isoformat()
            )
        
        except Exception as e:
            logger.error(f"‚ùå Error generando actividad h√≠brida: {e}")
            return ActividadEducativa(
                id=f"error_hibrido_{materia.lower() if materia else 'unknown'}_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                titulo=f"Error H√≠brido - {materia or 'Unknown'}",
                materia=materia or "unknown",
                tema=tema or "tema general",
                contenido=f"Error generando actividad h√≠brida: {e}",
                estudiantes_objetivo=[],
                tipo="error_hibrido",
                adaptaciones=[],
                metadatos={"error": str(e), "version": "hibrido_optimizado_1.0"},
                timestamp=datetime.now().isoformat()
            )
    
    def _construir_contenido_final(self, resultados: Dict[str, str], feedback_acumulado: List[FeedbackInteligente], quantum_insights: str) -> str:
        """Construye el contenido final estructurado"""
        
        contenido = "=" * 100 + "\n"
        contenido += "ACTIVIDAD GENERADA CON SISTEMA H√çBRIDO OPTIMIZADO\n"
        contenido += "Combina: Feedback Sem√°ntico + Validaci√≥n Cu√°ntica + Contexto Rico + Agentes D√≥ciles\n"
        contenido += "=" * 100 + "\n\n"
        
        # Informaci√≥n del procesamiento
        if quantum_insights:
            contenido += "üî¨ INSIGHTS CU√ÅNTICOS APLICADOS:\n"
            contenido += "-" * 50 + "\n"
            contenido += quantum_insights + "\n\n"
        
        # Feedback aplicado
        if feedback_acumulado:
            contenido += "üéØ FEEDBACK SEM√ÅNTICO APLICADO:\n"
            contenido += "-" * 50 + "\n"
            for i, feedback in enumerate(feedback_acumulado, 1):
                contenido += f"{i}. AGENTE: {feedback.agente_objetivo.upper()}\n"
                contenido += f"   Usuario: {feedback.prompt_usuario}\n"
                contenido += f"   Confianza: {feedback.confianza:.1%} | Intenci√≥n: {feedback.intencion_detectada}\n\n"
        
        # Fases de desarrollo
        fases = {
            'inspiracion': 'üé≠ SEMILLA CREATIVA E INSPIRACI√ìN',
            'pedagogia': 'üìö ESTRUCTURA PEDAG√ìGICA',
            'arquitectura': 'üèóÔ∏è ARQUITECTURA DE LA EXPERIENCIA',
            'diferenciacion': 'üéØ DIFERENCIACI√ìN PERSONALIZADA'
        }
        
        for fase_key, fase_titulo in fases.items():
            if fase_key in resultados:
                contenido += f"\n{fase_titulo}\n"
                contenido += "=" * len(fase_titulo) + "\n"
                contenido += resultados[fase_key] + "\n\n"
        
        contenido += "\n" + "=" * 100 + "\n"
        contenido += "SISTEMA H√çBRIDO OPTIMIZADO - Versi√≥n 1.0\n"
        contenido += f"Generado: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        contenido += "=" * 100 + "\n"
        
        return contenido
    
    def guardar_actividad(self, actividad: ActividadEducativa, output_dir: str = "actividades_hibrido_optimizado") -> str:
        """Guarda la actividad generada"""
        
        script_dir = os.path.dirname(os.path.abspath(__file__))
        full_output_dir = os.path.join(script_dir, output_dir)
        os.makedirs(full_output_dir, exist_ok=True)
        
        filename = f"{actividad.id}.txt"
        filepath = os.path.join(full_output_dir, filename)
        
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write("=" * 100 + "\n")
            f.write(f"ACTIVIDAD H√çBRIDA OPTIMIZADA\n")
            f.write("=" * 100 + "\n\n")
            f.write(f"ID: {actividad.id}\n")
            f.write(f"T√≠tulo: {actividad.titulo}\n")
            f.write(f"Materia: {actividad.materia}\n")
            f.write(f"Tema: {actividad.tema}\n")
            f.write(f"Tipo: {actividad.tipo}\n")
            f.write(f"Estudiantes objetivo: {', '.join(actividad.estudiantes_objetivo)}\n")
            f.write(f"Timestamp: {actividad.timestamp}\n")
            f.write("\n" + "-" * 80 + "\n")
            f.write("CONTENIDO DE LA ACTIVIDAD:\n")
            f.write("-" * 80 + "\n\n")
            f.write(actividad.contenido)
            f.write("\n\n" + "=" * 100 + "\n")
            f.write("METADATOS DEL SISTEMA H√çBRIDO OPTIMIZADO:\n")
            f.write(json.dumps(actividad.metadatos, indent=2, ensure_ascii=False))
            f.write("\n")
        
        logger.info(f"üíæ Actividad h√≠brida guardada en: {filepath}")
        return filepath

# =============================================================================
# FUNCI√ìN PRINCIPAL
# =============================================================================

def main():
    """Funci√≥n principal del sistema h√≠brido optimizado"""
    
    print("=" * 100)
    print("üöÄ SISTEMA DE AGENTES H√çBRIDO OPTIMIZADO")
    print("Combina lo mejor de todos los sistemas anteriores")
    print("=" * 100)

    try:
        # Configuraci√≥n
        OLLAMA_HOST = "192.168.1.10"
        MODELO_BASE = "qwen3:latest"
        PERFILES_PATH = "perfiles_4_primaria.json"

        print(f"\nüîß Inicializando Sistema H√≠brido:")
        print(f" Host Ollama: {OLLAMA_HOST}")
        print(f" Modelo base: {MODELO_BASE}")
        print(f" Caracter√≠sticas:")
        print(f"   ‚úÖ Feedback sem√°ntico autom√°tico")
        print(f"   ‚úÖ Validaci√≥n cu√°ntica con retry")
        print(f"   ‚úÖ Contexto rico separado")
        print(f"   ‚úÖ Agentes d√≥ciles (prompts cortos)")
        print(f"   ‚úÖ Human-in-the-loop inteligente")

        # Inicializar sistema
        sistema = SistemaAgentesHibridoOptimizado(
            ollama_host=OLLAMA_HOST,
            modelo_base=MODELO_BASE,
            perfiles_path=PERFILES_PATH
        )

        print("\n‚úÖ Sistema H√≠brido Optimizado inicializado correctamente!")
        print(f"üìñ Ejemplos K cargados: {len(sistema.ejemplos_k)}")
        print(f"üî¨ Quantum Enhancer: {'‚úÖ Activo' if sistema.quantum_enhancer else '‚ùå No disponible'}")

        while True:
            print("\n" + "="*80)
            print("üéì GENERACI√ìN H√çBRIDA OPTIMIZADA")
            print("1. üöÄ Generar actividad con sistema h√≠brido completo")
            print("2. ‚ùå Salir")

            opcion = input("\nüëâ Selecciona una opci√≥n (1-2): ").strip()
            
            if opcion == "1":
                print("\nüìù Describe tu actividad ideal:")
                print("Ejemplo: 'Actividad colaborativa de matem√°ticas sobre fracciones")
                print("         para estudiantes de 4¬∫ primaria, inclusiva para TEA'")
                prompt_inicial = input("\n‚ú® Tu prompt: ").strip()
                
                if not prompt_inicial:
                    print("‚ùå Por favor, proporciona un prompt")
                    continue
                
                start_time = datetime.now()
                actividad = sistema.generar_actividad_hibrida_optimizada(prompt_inicial)
                archivo = sistema.guardar_actividad(actividad)
                end_time = datetime.now()
                duration = (end_time - start_time).total_seconds()
                
                print(f"\nüéâ ACTIVIDAD H√çBRIDA GENERADA EXITOSAMENTE!")
                print(f"‚è±Ô∏è  Tiempo: {duration:.1f}s")
                print(f"üìÑ ID: {actividad.id}")
                print(f"üìÅ Archivo: {archivo}")
                print(f"üéØ Feedback aplicado: {actividad.metadatos.get('feedback_aplicado', 0)} elementos")
                
                if 'validacion_final' in actividad.metadatos:
                    val = actividad.metadatos['validacion_final']
                    print(f"üî¨ Validaci√≥n cu√°ntica: {val['puntuacion']:.2f} ({'‚úÖ Aprobado' if val['aprobado'] else '‚ùå Rechazado'})")
                
            elif opcion == "2":
                print("\nüëã ¬°Hasta luego!")
                break
            else:
                print("\n‚ùå Opci√≥n no v√°lida. Selecciona 1-2.")

    except Exception as e:
        print(f"\n‚ùå Error inicializando sistema h√≠brido: {e}")
        print("\nüí° Verifica que:")
        print(" 1. Ollama est√© ejecut√°ndose en el host especificado")
        print(" 2. El modelo especificado est√© disponible")
        print(" 3. El archivo quantum_enhancer.py est√© disponible")
        print(" 4. Los archivos de perfiles y ejemplos K est√©n en sus rutas")
        print(" 5. Las dependencias est√©n instaladas (crewai, langchain-community)")

if __name__ == "__main__":
    main()